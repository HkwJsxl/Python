### 死锁

抢没有释放的锁时，极其容易产生死锁现象（整个程序卡死，阻塞）

### 递归锁

递归锁的特点
				可以被连续的acquire和release
				但是只能被第一个抢到这把锁执行上述操作
		它的内部有一个计数器，每acquire一次计数加一每release一次计数减一
		只要计数不为0，那么其他人都无法抢到该锁

### 信号量

简单理解为多个互斥锁

```python
"""

from threading import Thread, Semaphore

"""
```

### Event事件

一些进程/线程需要等待另外一些进程/线程运行完毕之后才能运行，类似于发射信号一样

```python
"""
from threading import Thread, Event
event = Event()
event.set()
event.wait()

"""
```

### 线程q

~~~python
"""
import queue

'''先进先出'''
q = queue.Queue(5)

'''后进先出'''
q = queue.LifoQueue(5)

'''优先级'''
q = queue.PriorityQueue(5)
# put中放入元组，第一个表示优先级，第二个表示内容，数字越小，优先级越高

"""
~~~

### 进程池与线程池

#### 	为什么需要进程池和线程池

基于多进程或多线程实现并发的套接字通信，然而这种实现方式的致命缺陷是：

​	服务端的程序运行在一台机器身上，一台机器性能是有极限的，不能无限开线程

服务的开启的进程数或线程数都会随着并发的客户端数目地增多而增多，这会对服务端主机带来巨大的压力，甚至于不堪重负而瘫痪，于是我们必须对服务端开启的进程数或线程数加以控制，让机器在一个自己可以承受的范围内运行

#### 	线程池和进程池作用

我们不可能让计算机无休止的开进程和线程，因为资源是有限的，硬件的开发速度比不上软件

宗旨是提高效率的同时，必须保证硬件的安全

池的概念：

​		保证计算机硬件的安全条件下最大限度的利用硬件资源

​		降低了执行效率，保证了计算机硬件安全，使软件能够正常运行

#### 	什么时候开启线程和进程

计算机密集型程序用多进程，IO密集型用多线程



```python
"""

from concurrent.futures import ThreadPoolExecutor, ProcessPoolExecutor
pool = ThreadPoolExecutor()

pool = ProcessPoolExecutor()
pool.submit(task, i).add_done_callback(call_back)

"""
```

### 协程

进程：资源单位

线程：执行单位

协程：这个概念完全是程序员自己意淫出来的 根本不存在单线程下实现并发

​		我们程序员自己在代码层面上检测我们所有的IO操作一旦遇到IO了 我们在代码级别完成切换这样给CPU的感觉是你这个程序一直在运行 没有IO从而提升程序的运行效率

协程是单线程当中实现的并发，相对于开多个线程实现并发，省去了多个线程之间切换的开销，运行效率得到了提高

协程的作用是在执行函数A时随时可以去执行函数B，然后终端函数B去执行函数A（连续的自由切换）

协程优势：

-   执行效率极高，因为子程序切换（函数）不是线程切换，由程序自身控制，没有切换线程的开销。所以与多线程相比，线程的数量越多，协程性能的优势越明显。
-   不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在控制共享资源时也不需要加锁，因此执行效率高很多。

多道技术

​		切换+保存状态

​		CPU两种切换

​				程序遇到IO

​				程序长时间占用

切换不一定是提高效率

​		IO切，提升效率

​		没有IO，计算切，降低效率

保存状态

​		保存上一次的执行状态，等待下一次操作继续往后执行
​				yield

单线程并发

协程TCP服务端并发效果



~~~python
"""

from gevent import spawn
from gevent import monkey

monkey.patch_all()
# 猴子补丁

"""
~~~

